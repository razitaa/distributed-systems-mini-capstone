import json
import logging
from pprint import pformat
import random
import threading
from data.header import TorHeader
from node import Node
from data.cryptography import generate_rsa_key, decrypt_with_rsa, encrypt_with_aes, decrypt_with_aes
from data.circuit import Circuit
import tkinter as tk
from ast import literal_eval
from data.gui_logging_tools import *

class ClientNode(Node):

    def __init__(self, my_port: int, node_and_port_dict: dict, main_gui: tk.Tk):
        super().__init__(my_id=-1, my_port=my_port)
        self.node_and_port_dict = node_and_port_dict
        self.circuit_list = []
        self.event_list = []
        self.random_node_id_list = []

        # Client GUI
        # Code Generated By Pygubu Designer
        self.client_gui = tk.Tk()
        self.client_gui.title("Tor Client")
        self.client_gui.geometry("800x500")
        self.client_gui.resizable(False, False)
        frame3 = tk.Frame(self.client_gui)
        frame3.configure(height=400, width=200)
        frame6 = tk.Frame(frame3)
        frame6.configure(height=200, width=200)
        label2 = tk.Label(frame6)
        label2.configure(text='History')
        label2.pack(side="top")
        frame8 = tk.Frame(frame6)
        frame8.configure(height=200)
        self.event_history_listbox = tk.Listbox(frame8)
        self.event_history_listvar = tk.StringVar()
        self.event_history_listbox.configure(
            activestyle="none",
            listvariable=self.event_history_listvar,
            selectmode="single",
            width=35)
        self.event_history_listbox.pack(fill="y", side="left")
        self.event_history_scrollbar = tk.Scrollbar(frame8)
        self.event_history_scrollbar.configure(orient="vertical")
        self.event_history_scrollbar.pack(fill="y", side="left")
        frame8.pack(expand="true", fill="y", pady=10, side="top")
        frame6.pack(fill="y", padx=10, side="left")
        frame1 = tk.Frame(frame3)
        self.event_name = tk.Label(frame1)
        self.event_name.configure(
            text='Event name (misal: "Client: Generated Public/Private key pair")')
        self.event_name.pack(side="top")
        frame2 = tk.Frame(frame1)
        frame2.configure(height=200, width=200)
        self.event_detail = tk.Text(frame2)
        self.event_detail.configure(
            height=10, state="disabled", width=63, wrap="word")
        # _text_ = 'Mungkin disini potongan log?\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi a interdum eros. Phasellus non nisl ultricies, tempus lorem ac, finibus lectus. Vestibulum eget tellus fermentum, posuere magna et, tempor libero. Sed metus ante, dignissim et mi commodo, commodo mattis tortor. Nam suscipit ante in metus consectetur scelerisque. Praesent laoreet cursus tincidunt. Morbi vehicula suscipit eros at consectetur. Aliquam magna purus, facilisis vel feugiat ultricies, ultrices id est. Praesent ante justo, congue sit amet tempor id, accumsan nec erat. Ut et nibh risus. Sed vitae efficitur diam. Sed eu porta diam. Nunc dictum consequat magna, ut auctor neque imperdiet ut. Cras interdum enim augue, at mattis tellus laoreet a. Integer gravida magna eu mi venenatis, eu dictum elit placerat. Donec et finibus neque. Nullam mollis, risus sit amet maximus dictum, magna augue vestibulum metus, id pretium felis massa et dolor. In maximus justo orci, eu interdum odio viverra vitae. Nunc eu blandit justo, quis egestas urna. Etiam dapibus ligula nulla, nec efficitur tortor bibendum sagittis. Donec a massa sed arcu mollis fringilla. Nulla quam quam, tristique nec molestie quis, cursus eget risus. Nullam lorem sapien, egestas eu volutpat in, eleifend eu ante. Aliquam ultricies ornare convallis. Duis dui felis, pulvinar egestas ligula eu, dapibus pretium elit. Donec pretium a velit quis ultrices. Proin pretium eu turpis eu congue. Nulla nec luctus nisi. Duis tempor tincidunt lorem, ac ultrices nunc rutrum vel.'
        # self.event_detail.configure(state="normal")
        # self.event_detail.insert("0.0", _text_)
        # self.event_detail.configure(state="disabled")
        self.event_detail.pack(fill="y", side="left")
        self.event_detail_scrollbar = tk.Scrollbar(frame2)
        self.event_detail_scrollbar.configure(orient="vertical")
        self.event_detail_scrollbar.pack(fill="y", side="left")
        frame2.pack(expand="true", fill="both", pady=10, side="top")
        frame1.pack(fill="both", padx=10, side="left")
        frame3.pack(fill="both", pady=10, side="top")
        frame3.pack_propagate(0)
        frame7 = tk.Frame(self.client_gui)
        frame7.configure(height=200, width=200)
        self.next_step = tk.Button(frame7)
        self.next_step.configure(height=2, text='Next step', width=15)
        self.next_step.pack(side="top")
        frame7.pack(anchor="e", padx=20, pady=10, side="top")

        # Configure gui
        # History listbox
        self.event_history_listbox.configure(yscrollcommand=self.event_history_scrollbar.set)
        self.event_history_scrollbar.configure(command=self.event_history_listbox.yview)
        self.event_history_listbox.bind("<<ListboxSelect>>", self.on_event_listbox_select)

        # Event detail
        self.event_detail.configure(yscrollcommand=self.event_detail_scrollbar.set)
        self.event_detail_scrollbar.configure(command=self.event_detail.yview)

        # Next step button
        self.next_step.configure(command=self.gui_insert_next_step)

    def on_event_listbox_select(self, event):
        selected_index = self.event_history_listbox.curselection()[0]
        selected_event_name, selected_event_detail = self.event_list[selected_index]
        self.event_name.configure(text=selected_event_name)
        self.event_detail.configure(state="normal")
        self.event_detail.delete(1.0, tk.END)
        self.event_detail.insert(tk.END, selected_event_detail)
        self.event_detail.configure(state="disabled")

    def select_listbox_item(self, index):
        self.event_history_listbox.selection_clear(0, "end")
        self.event_history_listbox.selection_set(index)
        self.on_event_listbox_select(None)

    def gui_insert_next_step(self):
        next_index = self.event_history_listbox.size()
        self.event_history_listbox.insert("end", self.event_list[next_index][0])
        self.event_history_listbox.see(next_index)
        self.select_listbox_item(next_index)

        # Disable next step button if the last event is reached
        if self.event_history_listbox.size() == len(self.event_list):
            self.next_step.configure(state="disabled")

    def organize_event_for_simulation(self):
        # Store necessary logs into memory
        # don't forget to add server logs
        unread_logs_dict = dict()
        with open("logs/Client.txt", "r") as client_log:
            unread_logs_dict["Client"] = [line.rstrip('\n') for line in client_log.readlines()]
        index_of_relay_node_id_list_str = 8
        active_relay_node_id_list = literal_eval(unread_logs_dict["Client"][index_of_relay_node_id_list_str])
        del unread_logs_dict["Client"][index_of_relay_node_id_list_str - 1]
        del unread_logs_dict["Client"][index_of_relay_node_id_list_str]
        for each_node_id in active_relay_node_id_list:
            with open(f"logs/Relay {each_node_id}.txt", "r") as relay_log:
                unread_logs_dict[f"Relay {each_node_id}"] = [line.rstrip('\n') for line in relay_log.readlines()]

        # Start at client
        current_node_log = "Client"

        while True:
            # Find the next event start and stop line
            start_line = None
            stop_line = None
            for i, each_line in enumerate(unread_logs_dict[current_node_log]):
                # Find start line
                if each_line == "GUI_EVENT_START":
                    start_line = i
                # Find stop line
                if each_line == "GUI_EVENT_STOP":
                    stop_line = i - 1
                    break # Stop after finding stop line

            # Exit when no more gui event found
            if start_line == None or stop_line == None:
                return

            # Record the event to event dictionary
            event_name = unread_logs_dict[current_node_log][start_line + 1]
            log_line_start = start_line + 2
            self.event_list.append((event_name, "\n".join(unread_logs_dict[current_node_log][log_line_start:stop_line])))

            # Look up the next event location
            next_node = gui_event_get_next(unread_logs_dict[current_node_log][stop_line + 2])

            # Remove processed logs
            del unread_logs_dict[current_node_log][:stop_line + 3]

            current_node_log = next_node

    def start(self, circuit_len, message):

        self.build_circuit(circuit_len)
        self.send_request(message)

        logging.info("Listening for response...")
        inbound_message_json = self.listen_procedure()
        inbound_message = json.loads(inbound_message_json)
        data = inbound_message["data"]
        gui_event_start("Client: Receive server response")
        logging.info(f"\nINBOUND MESSAGE:\nTor header: {inbound_message['tor_header']}\nData: DATA encrypted with RELAY {self.random_node_id_list[0]} SESSION KEY\nSender port: {inbound_message['sender_port']}")
        gui_event_stop(next_node="Client")
        self.handle_response(data)

        # Start the client gui
        self.organize_event_for_simulation()
        # TODO get self.event_dict to show in gui
        # for event_name, event_log in self.event_list:
        #     print(event_name)
        #     print(event_log)
        #     print()
        self.gui_insert_next_step()
        self.client_gui.mainloop()

    def build_circuit(self, circuit_len: int):
        gui_event_start("Client: Choosing circuit route")

        logging.info(f"Available nodes for relay: {pformat(self.node_and_port_dict)}")
        logging.info(f"Building a circuit with {circuit_len} nodes")
        logging.info(f"Choosing {circuit_len} random node(s)...")
        self.random_node_id_list = random.sample(self.node_and_port_dict.keys(), circuit_len)
        circuit_dict = {key: self.node_and_port_dict[key] for key in self.random_node_id_list}
        route_str = ""
        for relay_id in circuit_dict.keys():
            route_str += f"Relay {relay_id} -- "
        logging.info(f"Route: Client -- {route_str}Server")
        logging.debug(f"\n{self.random_node_id_list}")
        gui_event_stop(next_node="Client")

        random_node_ports = list(circuit_dict.values())
        for i in range(len(random_node_ports)):
            gui_event_start(f"Client: Start establishing connection to Relay {self.random_node_id_list[i]}")
            logging.info("Starting circuit building loop...")
            # Create
            logging.info("Generating public/private key pair for session key encryptions...")
            logging.info(f"Target relay node: Relay {self.random_node_id_list[i]}")
            private_key, public_key = generate_rsa_key()
            logging.info(f"Public/Private key pair generated. Key will be used to encrypt session key from relay node.")
            message = dict()
            message["tor_header"] = TorHeader(i, "CREATE").__dict__
            message["data"] = {"gk": public_key}
            message["target_port"] = random_node_ports[i]
            logging.info(f"\nDATA:\nTor header: {message['tor_header']}\nData: CLIENT PUBLIC KEY\nTarget port: {message['target_port']}")

            # Extend
            if self.circuit_list: # If list is not empty
                gui_event_stop(next_node="Client")
                gui_event_start("Client: Applying layered encription")
                logging.info(f"Applying {len(self.circuit_list)} layer of encryption to message...")
                node_encryption_layer = []
                for each_relay_id_with_sk in self.random_node_id_list[:i]:
                    node_encryption_layer.append(f"Relay {each_relay_id_with_sk}")
                logging.info(f"Order of encryption key (from outer to inner): {node_encryption_layer}")
            for each_circuit in self.circuit_list[::-1]:
                logging.info(f"Encrypting data using RELAY {self.random_node_id_list[self.circuit_list.index(each_circuit)]} SESSION KEY...")
                outbound_message = json.dumps(message)
                encrypted_message = encrypt_with_aes(each_circuit.sk, outbound_message)
                message["tor_header"] = TorHeader(each_circuit.circuit_id, "EXTEND").__dict__
                message["data"] = encrypted_message
                message["target_port"] = each_circuit.upstream_port
            gui_event_stop(next_node="Client")

            # Send
            gui_event_start(f"Client: Sending message to Relay {self.random_node_id_list[0]}")
            logging.info("Sending message...")
            message["sender_port"] = self.my_port
            log_data = ""
            if (len(self.circuit_list) == 0):
                log_data += "CLIENT PUBLIC KEY"
            else:
                log_data += f"DATA encrypted with RELAY {self.random_node_id_list[0]} SESSION KEY"
            logging.info(f"\nOUTBOUND MESSAGE:\nTor header: {message['tor_header']}\nData: {log_data}\nTarget port: {message['target_port']}\nSender port: {message['sender_port']}")
            outbound_message = json.dumps(message)
            self.sending_procedure(outbound_message, random_node_ports[0])
            gui_event_stop(next_node=f"Relay {self.random_node_id_list[0]}")
            
            # Receive
            logging.info("Listening for reply...")
            inbound_message_json = self.listen_procedure()
            inbound_message = json.loads(inbound_message_json)
            data = inbound_message["data"]
            gui_event_start(f"Client: Receiving session key response from Relay {self.random_node_id_list[i]}")
            log_data = ""
            if (len(self.circuit_list) == 0):
                log_data += f"DATA encrypted with CLIENT PUBLIC KEY"
            else:
                log_data += f"DATA encrypted with RELAY {self.random_node_id_list[0]} SESSION KEY"
            logging.info(f"\nINBOUND MESSAGE:\nTor header: {message['tor_header']}\nData: {log_data}\nSender port: {message['sender_port']}")
            gui_event_stop(next_node="Client")
            gui_event_start(f"Client: Decrypting & storing session key from Relay {self.random_node_id_list[i]}")
            layer = 0
            for each_circuit in self.circuit_list:
                logging.info(f"Peeling encryption layer using RELAY {self.random_node_id_list[layer]} SESSION KEY...")
                decrypted_data = decrypt_with_aes(each_circuit.sk, data)
                if layer < len(self.circuit_list) - 1:
                    logging.info(f"DECRYPTED DATA: DATA encrypted with RELAY {self.random_node_id_list[layer+1]} SESSION KEY")
                else:
                    logging.info(f"DECRYPTED DATA: DATA encrypted with CLIENT PUBLIC KEY")
                data = json.loads(decrypted_data)["data"]
                layer += 1

            logging.info("Decrypting session key using CLIENT PUBLIC KEY...")
            sk = decrypt_with_rsa(private_key, data["sk"])
            logging.info(f"Storing received session key for port {random_node_ports[i]}...")
            new_circuit = Circuit(i, sk)
            new_circuit.upstream_port = random_node_ports[i]
            self.circuit_list.append(new_circuit)

            logging.info(f"CIRCUIT STORED:")
            debugstr = ""
            for circuit in self.circuit_list:
                debugstr += f"{str(circuit)}, upstream_port: {circuit.upstream_port}\n"
            logging.info(f"\n{debugstr}")
            if i < len(random_node_ports) - 1:
                gui_event_stop(next_node="Client")
        logging.info("Circuit built successfully")
        gui_event_stop(next_node="Client")

    def send_request(self, request_msg: str):

        gui_event_start(f"Client: Creating request message to send")
        logging.info("Starting procedure to send request message...")
        logging.info("Creating data...")
        message = dict()
        message["tor_header"] = TorHeader(len(self.circuit_list), "RELAY FORWARD").__dict__
        message["data"] = {"message": request_msg}
        message["target_port"] = 9999
        logging.info(f"\nDATA:\nTor header: {message['tor_header']}\nData: {message['data']}\nTarget port: {message['target_port']}")
        gui_event_stop(next_node="Client")

        gui_event_start(f"Client: Applying layered encryption to request message")
        logging.info("Start encrypting message...")
        for circuit in self.circuit_list[::-1]:
            logging.info(f"Encrypting message with session key from RELAY {self.random_node_id_list[self.circuit_list.index(circuit)]} SESSION KEY")
            outbound_message = json.dumps(message)
            encrypted_message = encrypt_with_aes(circuit.sk, outbound_message)
            message["tor_header"] = TorHeader(circuit.circuit_id, "RELAY FORWARD").__dict__
            message["data"] = encrypted_message
            message["target_port"] = circuit.upstream_port
            logging.info(f"\nENCRYPTED MESSAGE:\nTor header: {message['tor_header']}\nData: DATA encrypted with RELAY {self.random_node_id_list[self.circuit_list.index(circuit)]} SESSION KEY\nTarget port: {message['target_port']}")
        gui_event_stop(next_node="Client")

        gui_event_start(f"Client: Sending request message")
        #Sending message
        logging.info("Sending message...")
        message["sender_port"] = self.my_port
        logging.info(f"\nOUTBOUND MESSAGE:\nTor header: {message['tor_header']}\nData: DATA encrypted with RELAY {self.random_node_id_list[self.circuit_list.index(circuit)]} SESSION KEY\nTarget port: {message['target_port']}\nSender port: {message['sender_port']}")
        outbound_message = json.dumps(message)
        self.sending_procedure(outbound_message, self.circuit_list[0].upstream_port)
        gui_event_stop(next_node=f"Relay {self.random_node_id_list[0]}")

    def handle_response(self, response: str):
        gui_event_start(f"Client: Decrypting response message")
        logging.info("Start peeling encryption layers...")
        layer = 0
        for each_circuit in self.circuit_list:
            logging.info(f"Decrypting message with RELAY {self.random_node_id_list[layer]} SESSION KEY...")
            decrypted_data = decrypt_with_aes(each_circuit.sk, response)
            log_data = ""
            if layer < len(self.circuit_list) - 1:
                log_data += f"DATA encrypted with RELAY {self.random_node_id_list[layer+1]} SESSION KEY"
            else:
                log_data += str(json.loads(decrypted_data)["data"])
            logging.info(f"DECRYPTED DATA: {log_data}")
            response = json.loads(decrypted_data)["data"]
            layer += 1
        gui_event_stop(next_node=f"")

def thread_exception_handler(args):
    logging.error(f"Uncaught exception", exc_info=(args.exc_type, args.exc_value, args.exc_traceback))

def main(my_port: int, node_and_port_dict: dict, main_gui: tk.Tk, circuit_len: int, message: str):
    threading.excepthook = thread_exception_handler
    try:
        obj = ClientNode(my_port=my_port, node_and_port_dict=node_and_port_dict, main_gui=main_gui)
        obj.start(circuit_len, message)
    except Exception:
        logging.exception("Caught Error")
        raise

import json
import logging
from pprint import pformat
import random
import threading
from data.header import TorHeader
from node import Node
from data.cryptography import generate_rsa_key, decrypt_with_rsa, encrypt_with_aes, decrypt_with_aes
from data.circuit import Circuit
import tkinter as tk

class ClientNode(Node):

    def __init__(self, my_port: int, node_and_port_dict: dict, main_gui: tk.Tk):
        super().__init__(my_id=-1, my_port=my_port)
        self.node_and_port_dict = node_and_port_dict
        self.circuit_list = []

        # Client GUI
        # Code Generated By Pygubu Designer
        self.client_window = tk.Tk()
        self.client_window.title("Tor Client")
        self.client_window.geometry("800x500")
        self.client_window.resizable(False, False)
        frame3 = tk.Frame(self.client_window)
        frame3.configure(height=400, width=200)
        frame6 = tk.Frame(frame3)
        frame6.configure(height=200, width=200)
        label2 = tk.Label(frame6)
        label2.configure(text='History')
        label2.pack(side="top")
        frame8 = tk.Frame(frame6)
        frame8.configure(height=200)
        self.event_history_list = tk.Listbox(frame8)
        self.event_history_listvar = tk.StringVar()
        self.event_history_list.configure(
            listvariable=self.event_history_listvar, width=35)
        self.event_history_list.pack(fill="y", side="left")
        self.event_history_scrollbar = tk.Scrollbar(frame8)
        self.event_history_scrollbar.configure(orient="vertical")
        self.event_history_scrollbar.pack(fill="y", side="left")
        frame8.pack(expand="true", fill="y", pady=10, side="top")
        frame6.pack(fill="y", padx=10, side="left")
        frame1 = tk.Frame(frame3)
        self.event_name = tk.Label(frame1)
        self.event_name.configure(
            text='Event name (misal: "Client: Generated Public/Private key pair")')
        self.event_name.pack(side="top")
        frame2 = tk.Frame(frame1)
        frame2.configure(height=200, width=200)
        self.event_detail = tk.Text(frame2)
        self.event_detail.configure(
            height=10, state="disabled", width=63, wrap="word")
        _text_ = 'Mungkin disini potongan log?\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas egestas augue vel est gravida aliquam. Curabitur laoreet mattis leo. Duis quis nisi pretium, tincidunt ex id, egestas nulla. Vivamus sagittis malesuada purus congue consequat. Nullam hendrerit sapien condimentum magna congue condimentum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Phasellus a augue vel nunc finibus tincidunt. Morbi ullamcorper eros quis congue consequat. Maecenas eu sem eu odio varius porta. Fusce non hendrerit enim. Suspendisse diam justo, ornare in est vel, ultricies imperdiet neque. Phasellus in gravida elit. Sed cursus nisi quis tellus dapibus iaculis at id leo.'
        self.event_detail.configure(state="normal")
        self.event_detail.insert("0.0", _text_)
        self.event_detail.configure(state="disabled")
        self.event_detail.pack(fill="y", side="left")
        self.event_detail_scrollbar = tk.Scrollbar(frame2)
        self.event_detail_scrollbar.configure(orient="vertical")
        self.event_detail_scrollbar.pack(fill="y", side="left")
        frame2.pack(expand="true", fill="both", pady=10, side="top")
        frame1.pack(fill="both", padx=10, side="left")
        frame3.pack(fill="both", pady=10, side="top")
        frame3.pack_propagate(0)
        frame7 = tk.Frame(self.client_window)
        frame7.configure(height=200, width=200)
        self.next_step = tk.Button(frame7)
        self.next_step.configure(height=2, text='Next step', width=15)
        self.next_step.pack(side="top")
        frame7.pack(anchor="e", padx=20, pady=10, side="top")

    def start(self):
        self.client_window.mainloop()

        # logging.info(f"Available nodes for relay: {pformat(self.node_and_port_dict)}")
        # circuit_len = int(input("Total relay node to build a circuit (int): "))

        # logging.info(f"Building a circuit with {circuit_len} nodes")
        # self.build_circuit(circuit_len)
        # logging.info("Circuit built successfully")

        # logging.info("Starting procedure to send request message")
        # self.send_request(str(input("Enter message to send: ")))

        # logging.info("Listening for response...")
        # inbound_message_json = self.listen_procedure()
        # inbound_message = json.loads(inbound_message_json)
        # data = inbound_message["data"]
        # self.handle_response(data)

    def build_circuit(self, circuit_len: int):
        logging.info(f"Choosing {circuit_len} random node(s)...")
        random_node_id_list = random.sample(self.node_and_port_dict.keys(), circuit_len)
        circuit_dict = {key: self.node_and_port_dict[key] for key in random_node_id_list}
        route_str = ""
        for relay_id in circuit_dict.keys():
            route_str += f"Relay {relay_id} -- "
        logging.info(f"Route: Client -- {route_str}Server\n")

        random_node_ports = list(circuit_dict.values())
        for i in range(len(random_node_ports)):
            logging.info("Starting circuit building loop...")
            # Create
            logging.info("Initializing create data")
            private_key, public_key = generate_rsa_key()
            message = dict()
            message["tor_header"] = TorHeader(i, "CREATE").__dict__
            message["data"] = {"gk": public_key}
            message["target_port"] = random_node_ports[i]
            logging.info(f"Create data:\n{message}")

            # Extend
            if self.circuit_list: # If list is not empty
                logging.info(f"Applying {len(self.circuit_list)} layer of encryption to message...")
            for each_circuit in self.circuit_list[::-1]:
                outbound_message = json.dumps(message)
                encrypted_message = encrypt_with_aes(each_circuit.sk, outbound_message)
                message["tor_header"] = TorHeader(each_circuit.circuit_id, "EXTEND").__dict__
                message["data"] = encrypted_message
                message["target_port"] = each_circuit.upstream_port

            # Send
            logging.info("Sending message...")
            message["sender_port"] = self.my_port
            outbound_message = json.dumps(message)
            self.sending_procedure(outbound_message, random_node_ports[0])

            # Receive
            logging.info("Listening for reply...")
            inbound_message_json = self.listen_procedure()
            inbound_message = json.loads(inbound_message_json)
            data = inbound_message["data"]

            logging.info("Peeling encryption layer...")
            for each_circuit in self.circuit_list:
                logging.debug(f"data: {data}")
                decrypted_data = decrypt_with_aes(each_circuit.sk, data)
                logging.debug(f"decrypted data: {decrypted_data}")
                data = json.loads(decrypted_data)["data"]

            logging.info(f"Storing received session key for port {random_node_ports[i]}...")
            sk = decrypt_with_rsa(private_key, data["sk"])
            new_circuit = Circuit(i, sk)
            new_circuit.upstream_port = random_node_ports[i]
            self.circuit_list.append(new_circuit)

            debugstr = ""
            for circuit in self.circuit_list:
                debugstr += f"{str(circuit)}, upstream_port: {circuit.upstream_port}\n"
            logging.debug(f"\n{debugstr}")

    def send_request(self, request_msg: str):

        #Encrypt message
        logging.info("Start encrypting request message")
        message = dict()
        message["tor_header"] = TorHeader(len(self.circuit_list), "RELAY_FORWARD").__dict__
        message["data"] = {"message": request_msg}
        message["target_port"] = 9999
        logging.info(f"Create data:\n{message}")
        for circuit in self.circuit_list[::-1]:
            logging.info(f"Encrypting message with session key from relay node number {circuit.circuit_id}")
            outbound_message = json.dumps(message)
            encrypted_message = encrypt_with_aes(circuit.sk, outbound_message)
            message["tor_header"] = TorHeader(circuit.circuit_id, "RELAY_FORWARD").__dict__
            message["data"] = encrypted_message
            message["target_port"] = circuit.upstream_port

        #Sending message
        logging.info("Sending message...")
        message["sender_port"] = self.my_port
        outbound_message = json.dumps(message)
        self.sending_procedure(outbound_message, self.circuit_list[0].upstream_port)

    def handle_response(self, response: str):
        logging.info("Peeling encryption layer...")
        for each_circuit in self.circuit_list:
            logging.debug(f"data: {response}")
            decrypted_data = decrypt_with_aes(each_circuit.sk, response)
            logging.debug(f"decrypted data: {decrypted_data}")
            response = json.loads(decrypted_data)["data"]

def thread_exception_handler(args):
    logging.error(f"Uncaught exception", exc_info=(args.exc_type, args.exc_value, args.exc_traceback))

def main(my_port: int, node_and_port_dict: dict, main_gui: tk.Tk):
    threading.excepthook = thread_exception_handler
    try:
        obj = ClientNode(my_port=my_port, node_and_port_dict=node_and_port_dict, main_gui=main_gui)
        obj.start()
        # ClientNode(my_port=my_port, node_and_port_dict=node_and_port_dict, main_gui=main_gui)
    except Exception:
        logging.exception("Caught Error")
        raise

import json
import logging
from pprint import pformat
import random
import threading
from data.header import TorHeader
from node import Node
from data.cryptography import generate_rsa_key, decrypt_with_rsa, encrypt_with_aes, decrypt_with_aes
from data.circuit import Circuit
import tkinter as tk
from ast import literal_eval
from data.gui_logging_tools import *

class ClientNode(Node):

    def __init__(self, my_port: int, node_and_port_dict: dict, main_gui: tk.Tk):
        super().__init__(my_id=-1, my_port=my_port)
        self.node_and_port_dict = node_and_port_dict
        self.circuit_list = []
        self.event_list = []
        self.random_node_id_list = []

        # Client GUI
        # Code Generated By Pygubu Designer
        self.client_gui = tk.Tk()
        self.client_gui.title("Tor Client")
        self.client_gui.geometry("800x500")
        self.client_gui.resizable(False, False)
        frame3 = tk.Frame(self.client_gui)
        frame3.configure(height=400, width=200)
        frame6 = tk.Frame(frame3)
        frame6.configure(height=200, width=200)
        label2 = tk.Label(frame6)
        label2.configure(text='History')
        label2.pack(side="top")
        frame8 = tk.Frame(frame6)
        frame8.configure(height=200)
        self.event_history_list = tk.Listbox(frame8)
        self.event_history_listvar = tk.StringVar()
        self.event_history_list.configure(
            listvariable=self.event_history_listvar, width=35)
        self.event_history_list.pack(fill="y", side="left")
        self.event_history_scrollbar = tk.Scrollbar(frame8)
        self.event_history_scrollbar.configure(orient="vertical")
        self.event_history_scrollbar.pack(fill="y", side="left")
        frame8.pack(expand="true", fill="y", pady=10, side="top")
        frame6.pack(fill="y", padx=10, side="left")
        frame1 = tk.Frame(frame3)
        self.event_name = tk.Label(frame1)
        self.event_name.configure(
            text='Event name (misal: "Client: Generated Public/Private key pair")')
        self.event_name.pack(side="top")
        frame2 = tk.Frame(frame1)
        frame2.configure(height=200, width=200)
        self.event_detail = tk.Text(frame2)
        self.event_detail.configure(
            height=10, state="disabled", width=63, wrap="word")
        _text_ = 'Mungkin disini potongan log?\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas egestas augue vel est gravida aliquam. Curabitur laoreet mattis leo. Duis quis nisi pretium, tincidunt ex id, egestas nulla. Vivamus sagittis malesuada purus congue consequat. Nullam hendrerit sapien condimentum magna congue condimentum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Phasellus a augue vel nunc finibus tincidunt. Morbi ullamcorper eros quis congue consequat. Maecenas eu sem eu odio varius porta. Fusce non hendrerit enim. Suspendisse diam justo, ornare in est vel, ultricies imperdiet neque. Phasellus in gravida elit. Sed cursus nisi quis tellus dapibus iaculis at id leo.'
        self.event_detail.configure(state="normal")
        self.event_detail.insert("0.0", _text_)
        self.event_detail.configure(state="disabled")
        self.event_detail.pack(fill="y", side="left")
        self.event_detail_scrollbar = tk.Scrollbar(frame2)
        self.event_detail_scrollbar.configure(orient="vertical")
        self.event_detail_scrollbar.pack(fill="y", side="left")
        frame2.pack(expand="true", fill="both", pady=10, side="top")
        frame1.pack(fill="both", padx=10, side="left")
        frame3.pack(fill="both", pady=10, side="top")
        frame3.pack_propagate(0)
        frame7 = tk.Frame(self.client_gui)
        frame7.configure(height=200, width=200)
        self.next_step = tk.Button(frame7)
        self.next_step.configure(height=2, text='Next step', width=15)
        self.next_step.pack(side="top")
        frame7.pack(anchor="e", padx=20, pady=10, side="top")

    def start(self, circuit_len, message):

        self.build_circuit(circuit_len)
        self.send_request(message)

        logging.info("Listening for response...")
        inbound_message_json = self.listen_procedure()
        inbound_message = json.loads(inbound_message_json)
        data = inbound_message["data"]
        gui_event_start("Client: Receive server response")
        logging.info(f"\nINBOUND MESSAGE:\nTor header: {inbound_message['tor_header']}\nData: DATA encrypted with RELAY {self.random_node_id_list[0]} SESSION KEY\nSender port: {inbound_message['sender_port']}")
        gui_event_stop(next_node="Client")
        self.handle_response(data)

        # Start the client gui
        self.organize_event_for_simulation()
        # TODO get self.event_dict to show in gui
        for event_name, event_log in self.event_list:
            print(event_name)
            print(event_log)
            print()
        self.client_gui.mainloop()

    def organize_event_for_simulation(self):
        # TODO: Build the self.event_dict first
        # Store necessary logs into memory
        # don't forget to add server logs
        unread_logs_dict = dict()
        with open("logs/Client.txt", "r") as client_log:
            unread_logs_dict["Client"] = [line.rstrip('\n') for line in client_log.readlines()]
        index_of_relay_node_id_list_str = 8
        active_relay_node_id_list = literal_eval(unread_logs_dict["Client"][index_of_relay_node_id_list_str])
        del unread_logs_dict["Client"][index_of_relay_node_id_list_str - 1]
        del unread_logs_dict["Client"][index_of_relay_node_id_list_str]
        for each_node_id in active_relay_node_id_list:
            with open(f"logs/Relay {each_node_id}.txt", "r") as relay_log:
                unread_logs_dict[f"Relay {each_node_id}"] = [line.rstrip('\n') for line in relay_log.readlines()]

        # Start at client
        current_node_log = "Client"

        while True:
            # Find the next event start and stop line
            start_line = None
            stop_line = None
            for i, each_line in enumerate(unread_logs_dict[current_node_log]):
                # Find start line
                if each_line == "GUI_EVENT_START":
                    start_line = i
                # Find stop line
                if each_line == "GUI_EVENT_STOP":
                    stop_line = i - 1
                    break # Stop after finding stop line

            # Exit when no more gui event found
            if start_line == None or stop_line == None:
                return

            # Record the event to event dictionary
            event_name = unread_logs_dict[current_node_log][start_line + 1]
            log_line_start = start_line + 2
            self.event_list.append((event_name, "\n".join(unread_logs_dict[current_node_log][log_line_start:stop_line])))

            # Look up the next event location
            next_node = gui_event_get_next(unread_logs_dict[current_node_log][stop_line + 2])

            # Remove processed logs
            # unread_logs_dict[current_node_log] = unread_logs_dict[current_node_log][:stop_line + 2]
            del unread_logs_dict[current_node_log][:stop_line + 3]

            current_node_log = next_node

    def build_circuit(self, circuit_len: int):
        gui_event_start("Client: Choosing circuit route")

        logging.info(f"Available nodes for relay: {pformat(self.node_and_port_dict)}")
        logging.info(f"Building a circuit with {circuit_len} nodes")
        logging.info(f"Choosing {circuit_len} random node(s)...")
        self.random_node_id_list = random.sample(self.node_and_port_dict.keys(), circuit_len)
        circuit_dict = {key: self.node_and_port_dict[key] for key in self.random_node_id_list}
        route_str = ""
        for relay_id in circuit_dict.keys():
            route_str += f"Relay {relay_id} -- "
        logging.info(f"Route: Client -- {route_str}Server")
        logging.debug(f"\n{self.random_node_id_list}")
        gui_event_stop(next_node="Client")

        random_node_ports = list(circuit_dict.values())
        for i in range(len(random_node_ports)):
            gui_event_start(f"Client: Start establishing connection to Relay {self.random_node_id_list[i]}")
            logging.info("Starting circuit building loop...")
            # Create
            logging.info("Generating public/private key pair for session key encryptions...")
            logging.info(f"Target relay node: Relay {self.random_node_id_list[i]}")
            private_key, public_key = generate_rsa_key()
            logging.info(f"Public/Private key pair generated. Key will be used to encrypt session key from relay node.")
            message = dict()
            message["tor_header"] = TorHeader(i, "CREATE").__dict__
            message["data"] = {"gk": public_key}
            message["target_port"] = random_node_ports[i]
            logging.info(f"\nDATA:\nTor header: {message['tor_header']}\nData: CLIENT PUBLIC KEY\nTarget port: {message['target_port']}")

            # Extend
            if self.circuit_list: # If list is not empty
                gui_event_stop(next_node="Client")
                gui_event_start("Client: Applying layered encription")
                logging.info(f"Applying {len(self.circuit_list)} layer of encryption to message...")
                node_encryption_layer = []
                for each_relay_id_with_sk in self.random_node_id_list[:i]:
                    node_encryption_layer.append(f"Relay {each_relay_id_with_sk}")
                logging.info(f"Order of encryption key (from outer to inner): {node_encryption_layer}")
            for each_circuit in self.circuit_list[::-1]:
                logging.info(f"Encrypting data using RELAY {self.random_node_id_list[self.circuit_list.index(each_circuit)]} SESSION KEY...")
                outbound_message = json.dumps(message)
                encrypted_message = encrypt_with_aes(each_circuit.sk, outbound_message)
                message["tor_header"] = TorHeader(each_circuit.circuit_id, "EXTEND").__dict__
                message["data"] = encrypted_message
                message["target_port"] = each_circuit.upstream_port
            gui_event_stop(next_node="Client")

            # Send
            gui_event_start(f"Client: Sending message to Relay {self.random_node_id_list[0]}")
            logging.info("Sending message...")
            message["sender_port"] = self.my_port
            log_data = ""
            if (len(self.circuit_list) == 0):
                log_data += "CLIENT PUBLIC KEY"
            else:
                log_data += f"DATA encrypted with RELAY {self.random_node_id_list[0]} SESSION KEY"
            logging.info(f"\nOUTBOUND MESSAGE:\nTor header: {message['tor_header']}\nData: {log_data}\nTarget port: {message['target_port']}\nSender port: {message['sender_port']}")
            outbound_message = json.dumps(message)
            self.sending_procedure(outbound_message, random_node_ports[0])
            gui_event_stop(next_node=f"Relay {self.random_node_id_list[0]}")
            
            # Receive
            logging.info("Listening for reply...")
            inbound_message_json = self.listen_procedure()
            inbound_message = json.loads(inbound_message_json)
            data = inbound_message["data"]
            gui_event_start(f"Client: Receiving session key response from Relay {self.random_node_id_list[i]}")
            log_data = ""
            if (len(self.circuit_list) == 0):
                log_data += f"DATA encrypted with CLIENT PUBLIC KEY"
            else:
                log_data += f"DATA encrypted with RELAY {self.random_node_id_list[0]} SESSION KEY"
            logging.info(f"\nINBOUND MESSAGE:\nTor header: {message['tor_header']}\nData: {log_data}\nSender port: {message['sender_port']}")
            gui_event_stop(next_node="Client")
            gui_event_start(f"Client: Decrypting & storing session key from Relay {self.random_node_id_list[i]}")
            layer = 0
            for each_circuit in self.circuit_list:
                logging.info(f"Peeling encryption layer using RELAY {self.random_node_id_list[layer]} SESSION KEY...")
                decrypted_data = decrypt_with_aes(each_circuit.sk, data)
                if layer < len(self.circuit_list) - 1:
                    logging.info(f"DECRYPTED DATA: DATA encrypted with RELAY {self.random_node_id_list[layer+1]} SESSION KEY")
                else:
                    logging.info(f"DECRYPTED DATA: DATA encrypted with CLIENT PUBLIC KEY")
                data = json.loads(decrypted_data)["data"]
                layer += 1

            logging.info("Decrypting session key using CLIENT PUBLIC KEY...")
            sk = decrypt_with_rsa(private_key, data["sk"])
            logging.info(f"Storing received session key for port {random_node_ports[i]}...")
            new_circuit = Circuit(i, sk)
            new_circuit.upstream_port = random_node_ports[i]
            self.circuit_list.append(new_circuit)

            logging.info(f"CIRCUIT STORED:")
            debugstr = ""
            for circuit in self.circuit_list:
                debugstr += f"{str(circuit)}, upstream_port: {circuit.upstream_port}\n"
            logging.info(f"\n{debugstr}")
            if i < len(random_node_ports) - 1:
                gui_event_stop(next_node="Client")
        logging.info("Circuit built successfully")
        gui_event_stop(next_node="Client")

    def send_request(self, request_msg: str):

        gui_event_start(f"Client: Creating request message to send")
        logging.info("Starting procedure to send request message...")
        logging.info("Creating data...")
        message = dict()
        message["tor_header"] = TorHeader(len(self.circuit_list), "RELAY FORWARD").__dict__
        message["data"] = {"message": request_msg}
        message["target_port"] = 9999
        logging.info(f"\nDATA:\nTor header: {message['tor_header']}\nData: {message['data']}\nTarget port: {message['target_port']}")
        gui_event_stop(next_node="Client")

        gui_event_start(f"Client: Applying layered encryption to request message")
        logging.info("Start encrypting message...")
        for circuit in self.circuit_list[::-1]:
            logging.info(f"Encrypting message with session key from RELAY {self.random_node_id_list[self.circuit_list.index(circuit)]} SESSION KEY")
            outbound_message = json.dumps(message)
            encrypted_message = encrypt_with_aes(circuit.sk, outbound_message)
            message["tor_header"] = TorHeader(circuit.circuit_id, "RELAY FORWARD").__dict__
            message["data"] = encrypted_message
            message["target_port"] = circuit.upstream_port
            logging.info(f"\nENCRYPTED MESSAGE:\nTor header: {message['tor_header']}\nData: DATA encrypted with RELAY {self.random_node_id_list[self.circuit_list.index(circuit)]} SESSION KEY\nTarget port: {message['target_port']}")
        gui_event_stop(next_node="Client")

        gui_event_start(f"Client: Sending request message")
        #Sending message
        logging.info("Sending message...")
        message["sender_port"] = self.my_port
        logging.info(f"\nOUTBOUND MESSAGE:\nTor header: {message['tor_header']}\nData: DATA encrypted with RELAY {self.random_node_id_list[self.circuit_list.index(circuit)]} SESSION KEY\nTarget port: {message['target_port']}\nSender port: {message['sender_port']}")
        outbound_message = json.dumps(message)
        self.sending_procedure(outbound_message, self.circuit_list[0].upstream_port)
        gui_event_stop(next_node=f"Relay {self.random_node_id_list[0]}")

    def handle_response(self, response: str):
        gui_event_start(f"Client: Decrypting response message")
        logging.info("Start peeling encryption layers...")
        layer = 0
        for each_circuit in self.circuit_list:
            logging.info(f"Decrypting message with RELAY {self.random_node_id_list[layer]} SESSION KEY...")
            decrypted_data = decrypt_with_aes(each_circuit.sk, response)
            log_data = ""
            if layer < len(self.circuit_list) - 1:
                log_data += f"DATA encrypted with RELAY {self.random_node_id_list[layer+1]} SESSION KEY"
            else:
                log_data += str(json.loads(decrypted_data)["data"])
            logging.info(f"DECRYPTED DATA: {log_data}")
            response = json.loads(decrypted_data)["data"]
            layer += 1
        gui_event_stop(next_node=f"")

def thread_exception_handler(args):
    logging.error(f"Uncaught exception", exc_info=(args.exc_type, args.exc_value, args.exc_traceback))

def main(my_port: int, node_and_port_dict: dict, main_gui: tk.Tk, circuit_len: int, message: str):
    threading.excepthook = thread_exception_handler
    try:
        obj = ClientNode(my_port=my_port, node_and_port_dict=node_and_port_dict, main_gui=main_gui)
        obj.start(circuit_len, message)
    except Exception:
        logging.exception("Caught Error")
        raise
